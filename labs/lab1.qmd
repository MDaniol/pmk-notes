# Laboratorium 1

## Zakres Tematyczny

1. Wprowadzenie w temat obliczeń numerycznych w języku Python
2. Podstawy Pythona - Przypomnienie
3. Podstawy użycia bibliotek:
   1. Numpy
   2. SciPy
   3. MatPlotLib
4. Typy Danych w Numpy
5. Błędy numeryczne i ich propagacja
6. Biblioteka PyTorch

## Obliczenia numeryczne w języku Python

Obliczenia numeryczne odgrywają kluczową rolę w wielu dziedzinach nauki i inżynierii. Python, dzięki swoim bibliotekom i cechom języka, stał się popularnym wyborem do przeprowadzania obliczeń numerycznych. Oto kilka powodów, dla których Python jest często wybierany do tego celu:

**Czytelność:** Składnia Pythona jest przejrzysta i zwięzła, co pozwala na łatwe pisanie i analizę kodu.

**Biblioteki**: Python posiada bogaty zestaw bibliotek do obliczeń numerycznych, takich jak:

- NumPy: Biblioteka do obliczeń numerycznych, oferująca wsparcie dla dużych tablic i macierzy wielowymiarowych oraz zestaw funkcji matematycznych do ich operowania.
- SciPy: Oparta na NumPy, jest to biblioteka służąca do bardziej zaawansowanych obliczeń i algorytmów naukowych.
- Pandas: Biblioteka do analizy danych, która dostarcza struktury danych i funkcje niezbędne do czyszczenia, agregacji i analizy danych.

**Interaktywność**: Narzędzia takie jak Jupyter Notebook pozwalają na interaktywne eksplorowanie danych i obliczeń, co jest niezmiernie użyteczne w analizie naukowej.

**Integracja z innymi językami:** Python może być łatwo zintegrowany z kodem napisanym w językach takich jak C, C++ czy Fortran, co pozwala na łączenie szybkości tych języków z elastycznością Pythona.

**Wizualizacja Danych**: Biblioteki takie jak Matplotlib, Seaborn czy Plotly umożliwiają tworzenie zaawansowanych wizualizacji, które są kluczowe do analizy wyników obliczeń numerycznych.

**Wspólnota**: Python ma ogromną społeczność, która stale tworzy i udostępnia nowe narzędzia, biblioteki i zasoby do obliczeń numerycznych.

**Wszechstronność:** Poza obliczeniami numerycznymi, Python jest językiem ogólnego zastosowania, co oznacza, że można go używać również do web developmentu, automatyki, analizy danych, sztucznej inteligencji i wielu innych zastosowań. Dzięki temu badacze i inżynierowie mogą korzystać z jednego języka do wielu różnych zadań.

**Otwarte oprogramowanie**: Python jest językiem open source, co oznacza, że jest dostępny za darmo i ma dużą społeczność deweloperów pracujących nad jego rozwojem.

## Podstawy Pythona


### Czym jest Python i jak działa

Python to wysokopoziomowy język programowania stworzony przez Guido van Rossuma i po raz pierwszy opublikowany w 1991 roku. Charakteryzuje się czytelną składnią, która pozwala programistom wyrażać koncepty w mniejszej ilości kodu niż w językach takich jak C++ czy Java.

Działanie Pythona na poziomie szczegółów można opisać w kilku kluczowych krokach. W skrócie, działanie Pythona polega na tym, że kod źródłowy jest interpretowany przez interpreter Pythona w kod bajtowy, który następnie jest wykonywany przez maszynę wirtualną Pythona.

Oto bardziej szczegółowy przegląd tego, jak to działa:

1. **Kod źródłowy**: Wszystko zaczyna się od kodu źródłowego, który piszesz w pliku .py.

2. **Kompilacja do kodu bajtowego:** Gdy uruchamiasz skrypt Pythona, interpreter (zazwyczaj CPython, który jest standardową implementacją Pythona) kompiluje ten kod źródłowy w kod bajtowy. Kod bajtowy to niskopoziomowe, platformowo niezależne przedstawienie twojego kodu źródłowego. Zostaje on zapisany w plikach .pyc w katalogu __pycache__.

3. **Maszyna wirtualna Pythona (PVM):** Po skompilowaniu kodu, kod bajtowy jest przekazywany do Maszyny Wirtualnej Pythona (PVM). To tu właściwe wykonanie kodu ma miejsce. PVM interpretuje i wykonuje kod bajtowy linia po linii.

4. **Zarządzanie pamięcią:** Python automatycznie zarządza pamięcią dzięki mechanizmowi zwanej "garbage collection". Python posiada wbudowany licznik odniesień, który śledzi liczbę odniesień do każdego obiektu w pamięci. Gdy liczba odniesień do obiektu spada do zera, pamięć zajmowana przez obiekt jest automatycznie zwalniana. Dodatkowo, cykliczne odniesienia (gdzie obiekty odnoszą się nawzajem, ale nie są dostępne z żadnej innej części kodu) są wykrywane przez garbage collector i odpowiednio czyszczone.

5. **Rozszerzenia w języku C:** Jednym z mocnych stron Pythona jest jego zdolność do integrowania się z językami niższego poziomu, takimi jak C. Możesz pisać rozszerzenia w C, które są potem dostępne jako moduły w Pythonie. To pozwala na pisania bardziej wydajnych fragmentów kodu w C i korzystania z nich w Pythonie.

6. **Biblioteki standardowe:** Python ma bogate biblioteki standardowe, które oferują funkcje dla wielu powszechnych zadań, od pracy z plikami i sieciami po analizę danych i tworzenie interfejsów graficznych.

7. **Interfejs API C:** Python ma dobrze zdefiniowany API dla języka C, co pozwala na tworzenie rozszerzeń w C oraz na osadzanie interpretera Pythona w aplikacjach napisanych w C.

### Funkcje i przekazywanie argumentów
W języku Python najprostsza deklaracja funkcji wygląda następująco:

```python
def my_first_function():
    pass
```

Funkcja ta nie przyjmuje ani nie zwraca niczego.

Funkcje mogą przyjmowac argumenty:

**Argumenty pozycyjne:** Są to najczęściej używane argumenty. Przekazujesz je w kolejności, w jakiej są wymienione w definicji funkcji.

\

```python
def funkcja(a, b, c):
    print(a, b, c)

funkcja(1, 2, 3)  # 1 2 3
```

\

**Argumenty nazwane** (keyword arguments): Przekazujemy wartość, wskazując nazwę argumentu.

```python
funkcja(a=1, c=3, b=2)  # 1 2 3
```

\

**Domyślne wartości argumentów**: Możesz ustawić domyślne wartości dla niektórych (lub wszystkich) argumentów.

\

```python
def funkcja(a, b=2, c=3):
    print(a, b, c)

funkcja(1)  # 1 2 3
funkcja(1, c=4)  # 1 2 4
```

### Pętle

## Wybrane biblioteki numeryczne Pythona

### Biblioteka Numpy

**`NumPy`** to podstawowa biblioteka do obliczeń naukowych w Pythonie, która dostarcza wsparcie dla dużych, wielowymiarowych tablic i macierzy oraz wielu matematycznych funkcji do operacji na tych tablicach. Oto kilka najważniejszych cech biblioteki **`NumPy`** w kontekście metod numerycznych:

1. **Wektoryzacja**: 
   - Pozwala na wykonywanie operacji na całych tablicach bez potrzeby stosowania pętli. 
   - Operacje wektoryzowane są znacznie bardziej wydajne niż ich odpowiedniki bazujące na pętlach, dzięki zastosowaniu optymalizowanych funkcji niskiego poziomu napisanych w językach takich jak C i Fortran.

::: {.callout-tip}
## Przykład wektoryzacji

Załóżmy, że chcemy dodać elementy dwóch dużych list do siebie. Możemy to zrobić na dwa sposoby:

1. **Tradycyjnie:**

```python
list1 = [1, 2, 3, 4, 5]
list2 = [5, 4, 3, 2, 1]
result = []

for i in range(len(list1)):
    result.append(list1[i] + list2[i])

print(result)
```

2. **Z wykorzystaniem biblioteki NumPy i wektoryzacji:**

```python
import numpy as np

array1 = np.array([1, 2, 3, 4, 5])
array2 = np.array([5, 4, 3, 2, 1])

result_array = array1 + array2
print(result_array)
```

Zobaczmy teraz, co robi NumPy:

Gdy wykonujemy operację result_array = array1 + array2, NumPy wykonuje kilka kroków:

1. **Sprawdzanie wymiarów:**
Najpierw NumPy sprawdzi, czy obie tablice mają taki sam kształt (shape). Jeśli nie mają, zostanie zgłoszony błąd (chyba że możliwe jest "rozgłaszanie" (broadcasting), ale to bardziej zaawansowana funkcjonalność).

2. **Alokacja pamięci:**
NumPy alokuje pamięć dla wynikowej tablicy, która będzie miała taki sam kształt jak array1 i array2.
    
3. **Operacje element po elemencie:**
Następnie, dla każdego indeksu w tablicach, NumPy dodaje wartości z array1 i array2, a wynik zapisuje w odpowiednim miejscu w result_array.

W rzeczywistości, proces jest bardziej skomplikowany i zoptymalizowany pod kątem wydajności. Dzięki wektoryzacji i natywnym, optymalizowanym funkcjom niskiego poziomu, operacje takie jak ta są wykonane bardzo szybko.
:::



2. **Efektywna organizacja pamięci**:
- Tablice `NumPy` są jednorodne i przechowywane w ciągłych blokach pamięci. W przeciwieństwie do list w Pythonie, które są tablicami wskaźników, tablice `NumPy` zajmują mniej miejsca i umożliwiają szybszy dostęp do danych.
- Obsługuje też widoki (views), które pozwalają na dostęp do danych bez ich kopiowania, co jest szczególnie przydatne w dużych zbiorach danych.

3. **Paralelizacja**:
- Chociaż sama **`NumPy`** nie obsługuje paralelizacji na poziomie wielu wątków, jej operacje są zoptymalizowane do wykorzystania jednostek SSE/AVX dostępnych w nowoczesnych procesorach, co przyspiesza wiele operacji.
- Dodatkowo, biblioteki takie jak `Dask` czy `Numba` pozwalają na łatwą paralelizację i kompilację operacji **`NumPy`** dla jeszcze większej wydajności.

4. **Wsparcie dla operacji algebry liniowej, transformacji Fouriera i funkcji statystycznych**: 
- Dostarcza funkcje do rozwiązywania układów równań, obliczania wartości własnych, dekompozycji oraz innych kluczowych operacji algebry liniowej.
- Wbudowane funkcje do operacji na liczbach zespolonych oraz do wykonywania transformacji Fouriera.

5. **Wsparcie dla różnych typów danych**: 
- Obsługuje szeroki zakres typów danych, w tym typy liczbowe (całkowite, zmiennoprzecinkowe, zespolone) oraz typy dat i czasów.

6. **Interoperacyjność**:
- Może współdziałać z bibliotekami napisanymi w innych językach, takimi jak C, C++ czy Fortran, co pozwala na wykorzystanie istniejących, optymalizowanych kodów.
- Łatwa integracja z innymi bibliotekami do analizy danych, takimi jak `pandas` czy `SciPy`.

7. **Rozszerzalność**:
- Możliwość tworzenia własnych typów danych i funkcji `ufunc`, które zachowują się jak wbudowane operacje wektoryzowane.

W kontekście metod numerycznych, `NumPy` dostarcza solidne narzędzie do szybkiego i wydajnego przetwarzania danych oraz implementacji algorytmów numerycznych w Pythonie.

### Biblioteka Scipy
Drugą z wykorzystywanych przez nas bibliotek jest biblioteka SciPy - rozbudowana biblioteka służąca do obliczeń naukowych i inżynierskich w języku Python. Biblioteka ta bazuje na NumPy, ale dodaje sporo rzeczy "od siebie". Przejdźmy przez jej najważniejsze moduły:

1. Moduł do optymalizacji (`scipy.optimize`): Narzędzia do znajdowania korzeni równań i minimalizacji funkcji.

2. Moduł do algebry liniowej (`scipy.linalg`): Funkcje do rozwiązywania równań liniowych, obliczania wartości własnych itp.

3. Moduł do przetwarzania sygnałów (`scipy.signal`): Narzędzia do analizy, projektowania i przetwarzania sygnałów.

4. Moduł do analizy obrazów (`scipy.ndimage`): Funkcje do przetwarzania i analizy obrazów.

5. Moduł do statystyki (`scipy.stats`): Obszerna kolekcja funkcji do statystyki i rozkładów prawdopodobieństwa.

6. Moduł do całkowania (`scipy.integrate`): Narzędzia do całkowania funkcji i równań różniczkowych.

::: {.callout-tip}
## Przykład obliczeń z wykorzystaniem SciPy

Załóżmy, że chcemy znaleźc minimum jakiejś funkcji. Zobaczmy jak możemy to zrobic z wykorzystaniem biblioteki SciPy:

```python
from scipy.optimize import minimize

# Definiujemy funkcję
def f(x):
    return x**2 + 6*x + 5

# Znajdujemy minimum funkcji zaczynając od punktu x=0
result = minimize(f, x0=0)

# Wypisujemy wynik
print(f"Minimum value of f(x) is {result.fun} at x = {result.x}")
```
:::

Przeanalizujmy jeszcze jeden, bardzo ważny przykład, który łączy w sobie wykorzystanie biblioteki SciPy oraz pewne specyficzne cechy wykonywania obliczeń numerycznych.

::: {.callout-tip}
## Przykład rozwiązywania układu równań

W szpitalu są dwie grupy pacjentów: osoby z grypą i osoby z zatruciem pokarmowym. Pierwszego dnia przyszło 5 pacjentów z grypą i 3 z zatruciem pokarmowym. Wszyscy razem otrzymali 23 tabletki paracetamolu. Drugiego dnia przyszło 2 osoby z grypą i 3 z zatruciem pokarmowym, a łączna liczba tabletek paracetamolu, które dostali, wynosiła 13. Jaką dawkę paracetamolu otrzymuje pacjent z grypą oraz pacjent z zatruciem pokarmowym?

Załóżmy, że:

- Dawka dla pacjenta z grypą to $x$ tabletek.
- Dawka dla pacjenta z zatruciem to $y$ tabletek.

Na podstawie powyższych informacji uzyskujemy układ równań:

$5x+3y=23$ (pierwszy dzień)
$2x+3y=13$ (drugi dzień)

Rozwiążmy zatem ten układ równań, korzystając z biblioteki SciPy:

```python
import numpy as np
from scipy.linalg import solve

# Macierz współczynników
A = np.array([[5, 3], [2, 3]])

# Wektor wyników
b = np.array([23, 13])

# Rozwiązujemy układ równań
x, y = solve(A, b)

print(f"Dawka dla pacjenta z grypą: {x:.2f} tabletki")
print(f"Dawka dla pacjenta z zatruciem pokarmowym: {y:.2f} tabletki")
```
:::
### Biblioteka MatPlotLib

**Biblioteka `matplotlib`** to jedno z najpopularniejszych narzędzi do tworzenia wizualizacji danych w Pythonie. Dzięki niej można tworzyć różnorodne wykresy, od podstawowych liniowych czy słupkowych, po bardziej zaawansowane jak histogramy, wykresy punktowe czy konturowe.

**Najważniejsze cechy biblioteki `matplotlib`:**

1. **Wszechstronność**: Możliwość tworzenia wielu typów wykresów.
2. **Dostosowywalność**: Wielkie możliwości konfiguracji wyglądu wykresów.
3. **Interaktywność**: Możliwość tworzenia interaktywnych wizualizacji.
4. **Integracja z innymi bibliotekami**: `matplotlib` integruje się z wieloma innymi bibliotekami Pythona takimi jak `pandas` czy `numpy`.
5. **Podmoduł `pyplot`**: Zapewnia interfejs podobny do MATLAB-a, co jest przydatne dla osób znających to środowisko.
6. **Wsparcie dla różnych formatów**: Możliwość zapisu w wielu popularnych formatach graficznych jak PNG, PDF, SVG i innych.

::: {.callout-tip}
### Prosty przykład:

Stworzymy wykres przedstawiający funkcje sinus i cosinus na tym samym rysunku z dodatkową konfiguracją:

```python
import numpy as np
import matplotlib.pyplot as plt

# Dane
x = np.linspace(0, 2 * np.pi, 400)
y1 = np.sin(x)
y2 = np.cos(x)

# Tworzenie wykresu
plt.figure(figsize=(10,6))  # ustawienie rozmiaru wykresu
plt.plot(x, y1, label='sin(x)', color='blue', linewidth=2)  # wykres funkcji sinus
plt.plot(x, y2, label='cos(x)', color='red', linestyle='--', linewidth=2)  # wykres funkcji cosinus

# Dodanie tytułu i etykiet osi
plt.title('Funkcje sinus i cosinus')
plt.xlabel('x')
plt.ylabel('y')

# Dodanie siatki i legendy
plt.grid(True, which='both', linestyle='--', linewidth=0.5)
plt.legend()

# Wyświetlenie wykresu
plt.tight_layout()  # automatyczne dopasowanie elementów wykresu
plt.show()
```

Ten kod utworzy wykres funkcji sinus i cosinus. 
:::

## Typy danych

## Błędy numeryczne i ich propagacja

Rozpocznijmy od dwóch definicji:

- **Sygnał Analogowy:** - Sygnał w postaci wielkości fizycznej zmieniającej się w sposób ciągły, a nie skokowo. Jego wartości mogą zostać określone w każdej chwili. 

- **Sygnał Cyfrowy:** - Przeciwieństwem sygnału analogowego jest sygnał skwantowany, nazywany również dyskretnym. Kwantyzacja to działanie, które sygnał analogowy (liczbę rzeczywistą, o nieskończonym liczbie wartości w danym przedziale) przekształca w ograniczony zbiór liczb całkowitych, dzięki czemu możliwa jest dalsza obróbka tego sygnału przy pomocy komputera

::: {.callout-tip}
## Przykład kwantyzacji

Przykładem niech będzie sygnał EKG na obrazku poniżej

![EKG](images/lab1_probkowanie.png)

:::

Konwersja sygnału analogowego do cyfrowego zachodzi zawsze z pewną **ograniczoną dokładnością**. 
Dokładność ta wynika ze skończonej precyzji reprezentacji liczb w systemach cyfrowych. Nazywamy to błędem **kwantyzacji**. Wiąże się to bezpośrednio z typami danych. Drugim typem błędu, który nas interesuje to błąd **maszynowy**. 

**Błąd kwantyzacji:** Pojawia się, gdy sygnał ciągły lub sygnał o dużej rozdzielczości jest przetwarzany do ograniczonej liczby dyskretnych poziomów. Na przykład, gdy analogowy sygnał dźwiękowy jest digitalizowany, jego wartości amplitudy są zaokrąglane do najbliższego poziomu kwantyzacji. Błąd kwantyzacji odnosi się do różnicy między rzeczywistą wartością sygnału a jego kwantyzowaną wartością.

**Błąd maszynowy:** Jest to najmniejsza wartość, która może być reprezentowana w danym systemie numerycznym. Dla standardu liczby zmiennoprzecinkowej IEEE 754 (często używany w komputerach), błąd maszynowy określa minimalną różnicę między "1" a następną wartością, która może być reprezentowana. Błąd maszynowy jest ograniczeniem maszynowym i jest bezpośrednio związany z precyzją, z jaką liczby są reprezentowane w komputerze.

- Oba typy błędów wynikają z ograniczeń w reprezentowaniu liczb.
- W kontekście przetwarzania sygnałów, błąd kwantyzacji często jest bardziej widoczny, ponieważ wpływa bezpośrednio na jakość rekonstrukcji sygnału. Jednak w obliczeniach numerycznych, błąd maszynowy może kumulować się w wielu operacjach i wpływać na dokładność wyników.
- W praktycznych zastosowaniach DSP (cyfrowe przetwarzanie sygnałów), błąd kwantyzacji jest często większym problemem niż błąd maszynowy, chyba że algorytm wymaga dużej precyzji w obliczeniach matematycznych.

Błąd maszynowy, zwany także epsilonem maszynowym możemy w praktyce wyznaczyc korzystając z definicji, że jest to taka liczba, że:

$$1 + \epsilon \neq 1$${#eq-xyp}

 w arytmetyce zmiennoprzecinkowej komputera. Dla typu `float64` w bibliotece NumPy (co jest standardowym formatem liczby zmiennoprzecinkowej o podwójnej precyzji), epsilon maszynowy wynosi około $2.220446049250313 \cdot e^−16$.

### Zadania 

#### Zadanie 1 - Epsilon Maszynowy

Korzystając z definicji epsilonu maszynowego napisz funkcję w języku Python, która oblicza epsilon maszynowy danego typu danych w bibliotece NumPy. Pamiętaj o deklaracji typu danych w obliczeniach. Zalecane jest skorzystanie z pętli. 

#### Zadanie 2 - Paralelizacja

Poniżej przedstawiony jest kod, który mierzy czas wykonania pewnej operacji. Wykonaj analogiczne działanie z wykorzystaniem biblioteki NumPy, zmierz czas konieczny do jego wykonania, porównaj ten czas z czasem wykonania tradycyjnej metody.

```python
import math
import time

# Tworzymy listę wartości od 0 do 10^6
values = [i * 0.001 for i in range(1000000)]

start_time = time.time()

sin_values = []
for val in values:
    sin_values.append(math.sin(val))

end_time = time.time()
print(f"Traditional loop took {end_time - start_time} seconds")

```

#### Zadanie 3 - Kalkulator Oszczędnościowy
Twoim zadaniem jest stworzenie prostego kalkulatora oszczędnościowego, który pomoże użytkownikowi przewidzieć, ile pieniędzy uda mu się zaoszczędzić w ciągu określonego czasu.

**Wymagania:**

1. Użytkownik powinien mieć możliwość podania początkowej kwoty oszczędności (może to być 0).
2. Użytkownik powinien podać miesięczną kwotę, którą planuje oszczędzać.
3. Użytkownik powinien podać roczne oprocentowanie swojego konta oszczędnościowego (np. 3% oznaczać będzie 0.03).
4. Użytkownik powinien podać liczbę lat, przez które planuje oszczędzać.

**Twoim zadaniem jest:**

1. Obliczenie końcowej sumy oszczędności po określonym czasie, uwzględniając oprocentowanie.
2. Wykorzystanie odpowiednich typów danych w Pythonie do reprezentowania tych wartości (np. float dla kwot i oprocentowania, int dla liczby lat).

**Formuła oszczędności z oprocentowaniem składanym miesięcznie:**

$$A = P \left(1 + \frac{r}{n}\right)^{nt} + PMT \left[ \frac{\left(1 + \frac{r}{n}\right)^{nt} - 1}{\frac{r}{n}} \right]$$

Gdzie:

- A to końcowa suma oszczędności.
- P to początkowa suma oszczędności.
- r to roczna stopa procentowa (jako ułamek, np. 3% to 0.03).
- n to liczba okresów kapitalizacji w ciągu roku (dla kapitalizacji miesięcznej n=12n=12).
- t to liczba lat oszczędzania.
- PMT to stała miesięczna wpłata.



## Podstawy użycia bibliotek

### Numpy
### SciPy
### MatPlotLib

## Błędy numeryczne i ich propagacja

## Biblioteka Pytorch
